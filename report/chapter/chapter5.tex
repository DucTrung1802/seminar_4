\chapter{Thuật toán AprioriTid}

\section{Giới thiệu}

AprioriTid là một biến thể quan trọng của thuật toán Apriori truyền thống, được thiết kế nhằm giảm chi phí đọc lại toàn bộ cơ sở dữ liệu trong các vòng lặp sau mức 1. Điểm khác biệt chính giữa hai thuật toán nằm ở cách tính độ hỗ trợ (support) của các ứng viên. Trong khi Apriori phải truy cập lại toàn bộ tập giao dịch D ở mỗi mức k để xác định xem các ứng viên có xuất hiện trong giao dịch hay không, AprioriTid sử dụng một cấu trúc dữ liệu trung gian để đại diện cho thông tin cần thiết. Nhờ đó, khi mức k tăng lên (tức các ứng viên lớn dần), AprioriTid thường có hiệu năng tốt hơn.

\section{Ý tưởng và nguyên lý hoạt động}

AprioriTid vẫn sử dụng hàm sinh ứng viên apriori-gen giống Apriori. Tuy nhiên, thay vì quét cơ sở dữ liệu gốc D để đếm support, thuật toán duy trì một bảng trung gian Ck\_bar, trong đó mỗi dòng ứng với một giao dịch và chứa danh sách các ứng viên có khả năng xuất hiện trong giao dịch đó.

Một phần tử của Ck\_bar có dạng:

\begin{center}
\texttt{< TID , list\_of\_candidate\_itemsets >}
\end{center}

Trong đó:

\begin{itemize}
    \item TID là mã giao dịch.
    \item list\_of\_candidate\_itemsets là danh sách các ứng viên k-itemset có thể tồn tại trong giao dịch tương ứng.
\end{itemize}

Điểm mạnh của cấu trúc này là:

\begin{itemize}
    \item Không cần đọc lại toàn bộ dữ liệu D khi k >= 2.
    \item Khi k tăng, số lượng ứng viên trong mỗi giao dịch giảm mạnh, khiến kích thước Ck\_bar ngày càng nhỏ.
    \item Thời gian đếm support giảm đáng kể.
\end{itemize}

\section{Giả mã thuật toán AprioriTid}

Dựa trên slide, giả mã thuật toán được viết lại như sau:

\begin{verbatim}
1.  L1 = tập các frequent 1-itemset.
2.  C1_bar = cơ sở dữ liệu D ban đầu.
3.  For k = 2; khi L(k-1) không rỗng; tăng k lên:
4.      Ck = apriori-gen( L(k-1) ).   // Sinh ứng viên mới
5.      Ck_bar = rỗng.
6.      Với mỗi dòng t trong C(k-1)_bar:
7.          Xác định tập Cprime gồm các ứng viên trong Ck xuất hiện
                trong t (dựa trên tập các item cấp thấp hơn).
8.          Với mỗi c trong Cprime:
9.              Tăng bộ đếm c.count lên 1.
10.             Nếu Cprime không rỗng, đưa 
                < TID , Cprime > vào Ck_bar.
11.     Lk = các ứng viên trong Ck có c.count >= minsup.
12. Trả về hợp của tất cả Lk.
\end{verbatim}

Khác với Apriori:

\begin{itemize}
    \item Ở mức k = 1, AprioriTid giống hệt Apriori.
    \item Từ mức k = 2 trở đi, AprioriTid không sử dụng tập giao dịch D nữa mà chỉ dùng C(k-1)\_bar.
\end{itemize}

\section{Ví dụ minh họa}

Xét tập giao dịch sau:

\begin{center}
\begin{tabular}{|c|c|}
\hline
TID & Items \\ \hline
100 & 1\ 3\ 4 \\
200 & 2\ 3\ 5 \\
300 & 1\ 2\ 3\ 5 \\
400 & 2\ 5 \\
\hline
\end{tabular}
\end{center}

Giả sử ngưỡng hỗ trợ tối thiểu minsup = 2.

\subsection{Bước 1: Tìm L1 và C1\_bar}

Đếm support từng item:

\begin{itemize}
    \item \{1\}: xuất hiện 2 lần
    \item \{2\}: 3 lần
    \item \{3\}: 3 lần
    \item \{4\}: 1 lần (loại)
    \item \{5\}: 3 lần
\end{itemize}

Do đó:

\begin{itemize}
    \item L1 = \{1\}, \{2\}, \{3\}, \{5\}
\end{itemize}

C1\_bar chính là dữ liệu gốc, nhưng chuyển thành dạng:

\begin{center}
\texttt{< TID , set-of-1-itemsets >}
\end{center}

Ví dụ:

\begin{itemize}
    \item TID 100: \{1\}, \{3\}, \{4\}
    \item TID 200: \{2\}, \{3\}, \{5\}
    \item TID 300: \{1\}, \{2\}, \{3\}, \{5\}
    \item TID 400: \{2\}, \{5\}
\end{itemize}

\subsection{Bước 2: Sinh C2 và tính L2}

Từ L1, sinh C2 gồm các tập 2-itemset:

\begin{itemize}
    \item \{1 2\}, \{1 3\}, \{1 5\}
    \item \{2 3\}, \{2 5\}
    \item \{3 5\}
\end{itemize}

Dựa trên C1\_bar, ta xác định các ứng viên xuất hiện trong từng giao dịch:

\begin{itemize}
    \item TID 100: \{1 3\}
    \item TID 200: \{2 3\}, \{2 5\}, \{3 5\}
    \item TID 300: tất cả trừ \{1 2\} và \{1 5\}
    \item TID 400: \{2 5\}
\end{itemize}

Đếm support:

\begin{itemize}
    \item \{1 3\}: 2 lần
    \item \{2 3\}: 2 lần
    \item \{2 5\}: 3 lần
    \item \{3 5\}: 2 lần
    \item Các ứng viên còn lại: 1 lần hoặc 0
\end{itemize}

Do đó:

\begin{itemize}
    \item L2 = \{1 3\}, \{2 3\}, \{2 5\}, \{3 5\}
\end{itemize}

C2\_bar được xây dựng tương tự, ví dụ:

\begin{itemize}
    \item TID 100: \{1 3\}
    \item TID 200: \{2 3\}, \{2 5\}, \{3 5\}
    \item TID 300: \{1 3\}, \{2 3\}, \{2 5\}, \{3 5\}
    \item TID 400: \{2 5\}
\end{itemize}

\subsection{Bước 3: Sinh C3 và tính L3}

Join L2 để sinh các ứng viên 3-itemset:

\begin{itemize}
    \item \{2 3 5\}
\end{itemize}

Sử dụng C2\_bar:

\begin{itemize}
    \item TID 200: có \{2 3\} và \{2 5\} và \{3 5\}, nên chứa \{2 3 5\}
    \item TID 300: tương tự
    \item TID 100 và 400: không chứa đủ bộ 2-itemset cần thiết
\end{itemize}

Đếm support:

\begin{itemize}
    \item \{2 3 5\}: 2 lần
\end{itemize}

Suy ra:

\begin{itemize}
    \item L3 = \{2 3 5\}
\end{itemize}

C3\_bar chỉ còn:

\begin{itemize}
    \item TID 200: \{2 3 5\}
    \item TID 300: \{2 3 5\}
\end{itemize}

\subsection{Kết quả cuối cùng}

Các frequent itemsets của AprioriTid:

\begin{itemize}
    \item L1: \{1\}, \{2\}, \{3\}, \{5\}
    \item L2: \{1 3\}, \{2 3\}, \{2 5\}, \{3 5\}
    \item L3: \{2 3 5\}
\end{itemize}

Tập kết quả trùng hoàn toàn với Apriori truyền thống, nhưng số lần truy cập cơ sở dữ liệu giảm đáng kể.

\section{Nhận xét về thuật toán AprioriTid}

Ưu điểm:

\begin{itemize}
    \item Không cần đọc lại tập giao dịch gốc khi k >= 2.
    \item Kích thước bảng Ck\_bar giảm dần khi k tăng, do các ứng viên lớn thường hiếm.
    \item Xử lý nhanh hơn Apriori trên các tập dữ liệu lớn hoặc thưa.
\end{itemize}

Hạn chế:

\begin{itemize}
    \item Ở mức k = 1, AprioriTid giống Apriori nên không có lợi thế.
    \item Nếu dữ liệu có nhiều giao dịch rất lớn, kích thước Ck\_bar có thể lớn ở các mức đầu.
\end{itemize}

\section{Kết luận}

AprioriTid là một cải tiến quan trọng của Apriori, đặc biệt hữu ích khi dữ liệu lớn và các tập ứng viên kích thước cao trở nên hiếm. Việc lưu trữ và sử dụng bảng trung gian Ck\_bar giúp giảm đáng kể chi phí quét dữ liệu và mang lại hiệu quả cao hơn so với Apriori truyền thống ở các mức k lớn.
